# プログラミング勉強会

## 目的
- バックエンドの仕組みを理解し、実装できるようにする
- バックエンドのフレームワークを作れるようになる
- 現場で活躍できる力をつける


## 第1回：環境構築

### 概要:
 PostgreSQLとFastAPIアプリケーションをDocker環境で立ち上げる。

### 内容:
- docker-compose.yml を作成し、以下を構成する。
- PostgreSQLコンテナ（永続化ボリューム設定あり）
- FastAPIアプリケーションコンテナ（必要パッケージインストール済みのPythonイメージ使用）
- FastAPIアプリケーション側で、PostgreSQLへの接続情報を環境変数から読み込む。
- docker-compose up でアプリケーションとDBが同時に起動することを確認する。
- FastAPIのエンドポイント (/) にブラウザまたはcurlでアクセスし、"Hello World"が返ることを確認する。

### 作業ログ
1.  必要なツールのインストール
    - Docker
2. プロジェクトディレクトリの準備
3. docker-compose.ymlの作成
```
複数のDockerコンテナ（アプリやデータベースなど）をまとめて管理・起動するための設定ファイルです。
Dockerは、アプリやサービスを「コンテナ」という単位で動かします。例えば、Webアプリ用のコンテナと、データベース用のコンテナを別々に作ることが多いです。それぞれのコンテナを毎回手動で起動・設定するのは面倒です。そこで登場するのがdocker-compose.ymlです。
・どんなコンテナを使うか（例：Webアプリ、DB）
・それぞれの設定（例：使うイメージ、環境変数、ポート番号、データの保存場所など）
・どの順番で起動するか（依存関係）
```
1. FastAPIアプリケーションの準備
2. サービスの起動
    - docker compose up

### TODO:
- 環境構築 done
- ユーザストーリー(誰が・何をできるのか)を一覧化・整理する
- エンドポイント化する(API設計)
- swagger
- ER図、データベース設計
- 実装

## 第2回：API設計

### 概要:
API設計を行う。

### 内容:
- ユーザストーリー(誰が・何をできるのか)を一覧化・整理する
- エンドポイント化する(API設計)
- swaggerについて学ぶ
  
### 作業ログ
- エンドポイントの決め方
    - アクション(動詞)ごとに決める
    - リソースを名詞にし、メソッド(GET・POST・PUT・DELETEなど)を使って「動詞」の役割を担わせる -> こっちで良い
    - **RESTfulの原則**を意識
- レスポンスの書き方
    - swaggerでまとめて書く
- 本来の開発フロー
    - pythonでapiを実装 → swagger形式でjsonまたはyamlとして保存
    - 今回は勉強のため、手でswagger形式で仕様を確認していく(?)

## 第3回：API設計(続き)

### 概要:
- 座学、エンドポイントについて学ぶ。

### 内容:
- RESTfulなエンドポイントの設計について
- 良いURIの設計：「覚えやすく、どんな機能を持つURIなのかがひと目でわかる」
- URIはリソースを表現 (URI=リソースという認識)
    - 複数形
    - 動詞ではなく名詞
    - ユーザストーリーは動詞で考えるが、エンドポイントは名詞+CRUDメソッドで動詞を表現するべき
    - 例
        - GET /tickets - Retrieves a list of tickets
        - GET /tickets/12 - Retrieves a specific ticket
        - POST /tickets - Creates a new ticket
        - PUT /tickets/12 - Updates a specific ticket
        - DELETE /tickets/12 - Deletes a specific ticket
- RESTfulでない設計
    - 処理にURIが紐づくようなシステム(create_user, update_user, delete_userなど)
- ステートフル/ステートレス
    - 来客の顔をよく覚えている店員 / マニュアル通りに対応する店員

## 第4回：API設計(続き)

### 概要:
- API設計、エンドポイントとメソッド、IDなどを具体的に整理し、swaggerを書いてみる。

### 作業ログ
- HTTPメソッドの振り分け
    - ログイン・ログアウトはPOST
        - セッションや認証トークンを作成・削除する
    - パスワードリセットは2段階に分ける
        - パスワードのリセットトークンを作成する(POST)
        - パスワードのリセット(PUT)
    - アカウント削除はDELETE
        - 論理削除の場合でも、内部の実装に関係なくクライアント側から見て「削除された」と解釈されればDELETEの要件を満たす
        - API仕様上は「論理的にリソースを削除する」という意図を表す
    - 体重推移のグラフ取得
        - 体重記録一覧(records)があれば、それを描画するだけで良いのでわざわざAPIを作る必要はないのではないか？
        - →このようにAPI化するかフロントに持たせるかについては、使用する言語や実装によって判断が分かれる。
        - 不要になれば後から削除すればよいので、勉強のためにも一旦今回は作成する。
- swaggerの書き方(本質的なところだけ)
    - paths: エンドポイントを列挙する
        - エンドポイントのURI(フルパス)
            - メソッド(POST・GET・PUT・DELETE)
                - requestBody: リクエストに書くべきこと
                    - required: リクエストボディが必須かどうか
                    - content:
                        - application/json: (json形式が多い)
                            - schema:
                                - type: リクエストボディの型
                                - properties: リクエストボディのプロパティ
                                - required: 必須のプロパティ
                - responses: レスポンスに書くこと
                    - 次回やる

### TODO:
- swaggerの続き
- ER図、データベース設計
- 実装


## 第5回：swagger

### 概要:
- swaggerを手で書いてみる

### 作業ログ
- responses: レスポンスに書くこと
    - ステータスコード(色々あるがよく使うものだけ)
    - 成功
        - 2XX系
            - 200: OK(データを返す)
            - 201: Created(データを新規作成したことを明示したいとき)
            - 204: No Content(返すものがない)
    - エラー(何が原因か?)
        - 4XX: クライアントのエラー
            - 400: Bad Request
            - 401: Unauthorized
            - 403: Forbidden
            - 404: Not Found
        - 5XX: サーバのエラー
            - 500: Internal Server Error
            - 502: Bad Gateway
            - 503: Service Unavailable
            - 504: Gateway Timeout
    - ステータスコードより下には、レスポンスボディを書く(リクエストボディとだいたい同じ)
        - エラーの場合は$refで、共通の定義を参照することが多い
        - componentsで先に定義しておく
- 各エンドポイント・メソッドごとの注意点メモ
    - 新規アカウント作成では、パスワードは返さない
    - ログインでは、認証トークンとリフレッシュトークンを返す
        - リフレッシュトークンは、認証トークンの有効期限が切れたときに使う
        - 認証トークンの有効期限も返すことが多く、こちらは短めに設定
    - ログアウトにはリクエストボディが必須ではない
        - 認証情報が必要、security:フィールドを設定
        - 副作用として認証トークンを無効化、今回はリフレッシュトークンも無効化
        - 204: No Contentで返す
- くにおさんと話したメモ
    - 422は赤文字のエラー、400は普通のエラー
    - 422はバリデーションエラー、400はユーザに通知するエラー

### TODO:
- swaggerの続き
- ER図、データベース設計
- バックエンド実装
- Next.jsのチュートリアル
    - 公式チュートリアル(https://note.com/mega_gorilla/n/n43bff8af5247)
- フロントエンド実装
    - Next.js


## 第6回：swagger(続き)

### 概要:
- swaggerを手で書いてみる(プロフィール情報、パスワード)

### 作業ログ
- プロフィール情報
    - ユーザーIDはパスパラメータで渡す
    - 更新(PUT)の場合はプロパティをオプショナルにする
        - 全部空のリクエストを許容しているが、クライアント側で処理する方が自然？
    - メールアドレスの変更を別プロセス、APIも分けるべき？
        - かなりややこしいので、今回はプロフィール変更にまとめる？
- パスワードリセット
    - リセットのリクエスト
        - 成功は202(とは?)
        - エラーで404を使わない
            - メールアドレスの存在確認を攻撃者にさせない(ユーザー列挙攻撃を防ぐ)
    - リセットの実行
        - ログイン認証とリセットトークンは別なので、エラーを401にするのは変？
        - ユーザIDが存在しないのと同様に、無効なトークンに対して404を返す？
        - GPTは400を推奨
    - 

## 第7回：swagger(続き)、バックエンド実装

### 概要:
- swaggerを手で書いてみる(体重記録レコード)

### 作業ログ
- エンドポイントにパスパラメータがある場合
    - 必ずparametersフィールドを設定しないといけない
- 体重記録レコード
    - すでにレコードが存在している日に新規作成しようとした場合は、エラーを返す
    - ユーザ・レコードのいずれかが存在しない場合、まとめて404を返す
- バックエンドの実装
    - フォルダ構成
        - app/models: データベースモデル
        - app/schemas: PydanticでAPIのリクエスト・レスポンスの形式定義(バリデーション)
        - app/crud: データベース操作(CRUD)
        - app/api: エンドポイント(API)
          - v1: バージョン管理
          - docs: swaggerファイル
        - app/core: 設定・共通機能(データベース接続、認証設定、環境変数などの一元管理)
        - app/utils: ユーティリティ関数
    - dockerに入ってコード実行できるか確認
        - docker compose exec app bashでコンテナ入る
        - 入ったところ(/app)ではなくルート直下にvolumeでマウントされている(/workspace)
    - データベースの接続確認完了
- くにおさんレビュー
    - フィールド名はエンティティの名前を含めない(user_id -> idなど)


### TODO:
- API設計のフィードバック
    - フィールド名修正する
- バックエンド実装
    - データベースモデル定義
        - Userモデルの作成
        - WeightRecordモデルの作成
        - リレーションシップの設定
        - テーブルの作成処理
    - etc.
- Next.jsの公式チュートリアル(https://note.com/mega_gorilla/n/n43bff8af5247)
- フロントエンド実装(Next.js)


## 第8回：バックエンド実装(続き)

### 概要:
- データベースモデル定義

### 作業ログ
- フィールド名の修正
    - 改めて、idはエンティティの名前を含めない処理で良いのかどうか？
    - テーブル定義はそれで良いが、プロパティのフィールド名はカラム名に合わせるべきなのかどうか
    - 要確認・相談
- データベースモデル定義

